day 01
1,JWT令牌：
    Header：声明类型（JWT）和签名算法（HS256/RS256…）
    Payload：业务数据（userId、role、exp 等）
    Signature：防篡改校验，确保Token未被修改
2,md5加密技术的使用方法：
    DigestUtils.md5DigestAsHex("123456".getBytes());
3,swagger和yapi都是与接口文档有关，区别在于：
    yapi是设计阶段使用的工具，管理和维护接口
    swagger是在开发阶段使用的框架，帮助后端开发
4,swagger常用注解：
    @Api:用在类上，例如Controller，表示对类的说明
    @ApiModel:用在类上，例如entity，DTO，VO
    @ApiModelProperty:用在属性上，描述属性信息
    @ApiOperation:用在方法上，例如Controller的方法，说明方法的用途，作用

day 02
1,DTO:封装用户可传递的参数对象，VO是服务端筛选返回的数据对象，entity是数据库所有字段属性对象
2,@RequestBody:把json、xml类型的数据封装成一个java对象
3,long型的数据后面要加一个L
4,客户端发送的每一次请求都是单独的一个线程（多线程的知识点要看）
5,将JSON解析为java对象的过程称为“从JSON反序列化Java对象”
  将Java对象生成JSON对象的过程称为“序列化Java对象到JSON”
6,对日期进行格式化：
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")是对单个日期进行格式化，用在哪里就在哪上面加
    在配置类中扩展Spring mvc消息转换器并为其设置一个对象转换器，将java数据转换为序列化为json数据，然后将自己的消息转换器添加到容器中
7,@PathVariable(value="xxx")是指在路径上的占位符，xxx将参数名与路径名相匹配
8,在实体类上加@Builder后定义对象可以这么写：
    Employee employee = Employee.builder()
            .status(status)
            .id(id)
            .build();
9,parameterType: 接口中方法参数的类型， 类型的完全限定名或别名。

day 03
1,反射：程序在 “运行时”，能动态获取类的信息（比如类有哪些属性、方法、构造器），还能动态调用这些方法或修改属性的能力
  动态代理：在 “运行时” 动态创建一个 “代理对象”，这个代理对象能替代原对象被调用，并且在原对象的方法执行前后，偷偷插入额外逻辑
  AOP（面向切面编程）：实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术，如更新create_user，减少代码冗余
      横切关注点：指那些贯穿于多个模块、与业务逻辑无关但又必须实现的功能（如日志记录、事务管理、权限校验、异常处理等）。
      核心思想：将横切关注点从业务逻辑代码中抽离出来，形成独立的 “切面”，通过 “织入” 机制动态整合到业务代码中，实现 “关注点分离”，提高代码复用性和可维护性
2,自定义一个注解
  首先在某个包下定义一个注解类型（在java类里面），然后在上面加上元注解@Target("ElementType.Method")和@Retention(RetentionPolicy.RUNTIME)这样的注解
      元注解：可以写在注解上面的注解  @Target ：指定注解能在哪里使用  @Retention ：可以理解为保留时间(生命周期)
  接着在方法中定义数据库操作类型.然后自定义一个切面类
  在切面类中定义切入点和通知
3,看枚举
4,@Slf4j: Lombok 框架提供的注解，核心作用是自动生成日志对象，省去手动定义日志对象的模板代码
  @Component: Spring 框架提供的注解，核心作用是告诉Spring：“这个类是一个组件，你在启动时帮我创建它的对象，并管好它”.其兄弟注解是Controller，Service这种




