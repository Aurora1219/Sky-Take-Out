day 01
1,JWT令牌：
    Header：声明类型（JWT）和签名算法（HS256/RS256…）
    Payload：业务数据（userId、role、exp 等）
    Signature：防篡改校验，确保Token未被修改
2,md5加密技术的使用方法：
    DigestUtils.md5DigestAsHex("123456".getBytes());
3,swagger和yapi都是与接口文档有关，区别在于：
    yapi是设计阶段使用的工具，管理和维护接口
    swagger是在开发阶段使用的框架，帮助后端开发
4,swagger常用注解：
    @Api:用在类上，例如Controller，表示对类的说明
    @ApiModel:用在类上，例如entity，DTO，VO
    @ApiModelProperty:用在属性上，描述属性信息
    @ApiOperation:用在方法上，例如Controller的方法，说明方法的用途，作用

day 02
1,DTO:封装用户可传递的参数对象，VO是服务端筛选返回的数据对象，entity是数据库所有字段属性对象
2,@RequestBody:把json、xml类型的数据封装成一个java对象
3,long型的数据后面要加一个L
4,客户端发送的每一次请求都是单独的一个线程（多线程的知识点要看）
5,将JSON解析为java对象的过程称为“从JSON反序列化Java对象”
  将Java对象生成JSON对象的过程称为“序列化Java对象到JSON”
6,对日期进行格式化：
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")是对单个日期进行格式化，用在哪里就在哪上面加
    在配置类中扩展Spring mvc消息转换器并为其设置一个对象转换器，将java数据转换为序列化为json数据，然后将自己的消息转换器添加到容器中
7,@PathVariable(value="xxx")是指在路径上的占位符，xxx将参数名与路径名相匹配
8,在实体类上加@Builder后定义对象可以这么写：
    Employee employee = Employee.builder()
            .status(status)
            .id(id)
            .build();
9,parameterType: 接口中方法参数的类型， 类型的完全限定名或别名。

day 03
1,反射：程序在 “运行时”，能动态获取类的信息（比如类有哪些属性、方法、构造器），还能动态调用这些方法或修改属性的能力
      第一步就是获取类对象（类名.class，Class.forName(存在路径)，对象.getClass()）
      第二步就是获取类中的成分
        获取类的构造器（getConstructors(),getDeclaredConstructors()[牛，可以拿私有的构造器],getConstructors(数据类型.class),getDeclaredConstructors(数据类型.class)）
        获取类的成员变量（把Constructors变成Field）
        获取类的成员方法（把Constructors变成Method）
      第三步就是明确使用的作用
        类的构造器可以用来创建对象（con.newInstance()）
        类的成员变量可以用来取值赋值（field.set(对象，属性值),field.getType(),field.getName()）
        类的成员方法可以用来执行（method.invoke()就是触发某个对象的该方法执行）
      暴力反射：setAccessible(true)
  动态代理：在 “运行时” 动态创建一个 “代理对象”，这个代理对象能替代原对象被调用，并且在原对象的方法执行前后，偷偷插入额外逻辑
  AOP（面向切面编程）：实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术，如更新create_user，减少代码冗余
      横切关注点：指那些贯穿于多个模块、与业务逻辑无关但又必须实现的功能（如日志记录、事务管理、权限校验、异常处理等）。
      核心思想：将横切关注点从业务逻辑代码中抽离出来，形成独立的 “切面”，通过 “织入” 机制动态整合到业务代码中，实现 “关注点分离”，提高代码复用性和可维护性
      JoinPoint:连接点，可以被AOP控制的方法。执行原始方法：JoinPoint.proceed()
      Advice:通知，指那些重复的逻辑，也就是共性功能
      PointCut:切入点，匹配连接点的条件，通知仅会在切入点方法执行时被应用。execution(修饰符?返回值 包名.类名.?方法名（参数）throws 异常),@annotation(注解全类名)
      Aspect:切面，描述通知与切入点的对应关系
      Target:目标对象
2,自定义一个注解
  首先在某个包下定义一个注解类型（在java类里面），然后在上面加上元注解@Target("ElementType.Method")和@Retention(RetentionPolicy.RUNTIME)这样的注解
      元注解：可以写在注解上面的注解  @Target ：指定注解能在哪里使用  @Retention ：可以理解为保留时间(生命周期)
  接着在方法中定义数据库操作类型.然后自定义一个切面类
  在切面类中定义切入点和通知
3,枚举都是最终类，不能被继承。public enum A(){}
4,@Slf4j: Lombok 框架提供的注解，核心作用是自动生成日志对象，省去手动定义日志对象的模板代码
  @Component: Spring 框架提供的注解，核心作用是告诉Spring：“这个类是一个组件，你在启动时帮我创建它的对象，并管好它”.其兄弟注解是Controller，Service这种
  @Aspect: 表明这是一个AOP类
  @Transactional:表明这是一个原子操作。注意：要先用@EnableTransactionManagement开启注解方式的事务管理
5,




